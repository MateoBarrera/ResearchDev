"""_summary_

Returns:
    _type_: _description_
"""
import numpy as np
import pandas as pd  # pylint: disable=import-error
from prettytable import PrettyTable  # pylint: disable=import-error


def open_excel(path, sheet_name="Form Responses 1"):
    """_summary_

    Args:
        path (_type_): _description_
        sheet_name (str, optional): _description_. Defaults to "Form Responses 1".

    Returns:
        _type_: _description_
    """
    result = pd.read_excel(path, sheet_name=sheet_name)
    result = result.dropna(axis=1, how="all")
    # print(result.head())
    return result


def print_table(title, series):
    """_summary_

    Args:
        title (_type_): _description_
        series (_type_): _description_
    """
    table = PrettyTable()
    table.title = title
    table.field_names = series.columns.tolist()
    for row in series.itertuples():
        table.add_row([row.Experto, row[2]])
    print(table)


def print_evaluation(name_matrix, matrix, wj_array):
    """_summary_

    Args:
        name_matrix (_type_): _description_
        matrix (_type_): _description_
        wj_array (_type_): _description_
    """
    table = PrettyTable()
    table.title = name_matrix
    matrix = np.round_(matrix, decimals=2)
    if wj_array.any() == None:
        consistency = "NO"
    else:
        wj_array = np.round_(wj_array, decimals=2)
        consistency = "OK"
    table.field_names = ["Matriz", "Consistencia", "Vector de pesos"]
    table.add_row([matrix, consistency, wj_array])
    print(table)


class Criteria:
    """This class The criteria class allows the loading of peer evaluations generated by experts,
    constructing the matrix of weights per criterion used in the MCDA method.
    """

    weight_criteria: object
    __show: bool

    def __init__(self) -> None:
        self.__show = False

    @property
    def show_all(self):
        """_summary_

        Returns:
            _type_: _description_
        """
        return self.__show

    @show_all.setter
    def show_all(self, value):
        if isinstance(value, bool):
            self.__show = value

    def __consistency_index(self, n_criteria, lmax):
        if n_criteria == 2:
            ci_index = 0
            cr_index = 0
        else:
            ri_array = {
                3: 0.5247,
                4: 0.8816,
                5: 1.1086,
                6: 1.2479,
                7: 1.3417,
                8: 1.4057,
                9: 1.4499,
                10: 1.4854,
            }
            ci_index = (lmax - n_criteria) / (n_criteria - 1)
            cr_index = ci_index / ri_array[n_criteria]
        return ci_index, cr_index

    def __consistency_check(self, matrix, name_matrix):
        sum_rows = np.sum(matrix, 0)
        normalized_matrix = matrix / sum_rows
        wj_array = np.mean(normalized_matrix, 1)

        # wj_array = [round(x,6) for x in wj_array]

        criteria_sum = np.sum(matrix * wj_array, 1)
        dj_value = criteria_sum / wj_array
        lmax = np.mean(dj_value)

        ci_index, cr_index = self.__consistency_index(len(matrix), lmax)
        if cr_index > 0.10:
            wj_array = None
        if self.__show:
            print_evaluation(name_matrix, matrix, wj_array)
        return wj_array, ci_index

    def __criteria_matriz_by_expert(self, df_file, name_matrix):
        """[ambiental económico técnico]"""

        def cx_extract(text):
            return (
                int(list(str(text).split()[0])[-2])
                if (str(text)[0] == "C")
                else int(str(text).split(".", maxsplit=1)[0])
            )

        df_file = df_file.apply(cx_extract)
        dim = list()
        value = list()
        for index, item in enumerate(df_file):
            if index % 2 == 0:
                dim.append(item)
            else:
                value.append(item)
                index += index
        size_matrix = int(len(df_file) / 2)
        matrix = np.ones([size_matrix, size_matrix])
        expected = [1, 1, 2]

        for row_index in range(size_matrix):
            for column_index in range(size_matrix):
                if row_index < column_index:
                    aux = row_index + column_index - 1
                    if dim[aux] == expected[aux]:
                        matrix[row_index, column_index] = float(value[aux])
                        matrix[column_index, row_index] = 1 / float(value[aux])
                    else:
                        matrix[row_index, column_index] = 1 / float(value[aux])
                        matrix[column_index, row_index] = float(value[aux])
        return self.__consistency_check(matrix, name_matrix)

    def __criteria(self, df_file):
        df_file = df_file[df_file.columns[1:7]]
        list_wc = list()
        list_ci = list()

        for evaluation in range(len(df_file)):
            name_matrix = f"Criterios experto {evaluation + 1}"
            weights, ci_index = self.__criteria_matriz_by_expert(
                df_file.iloc[evaluation], name_matrix=name_matrix
            )
            list_wc.append(weights)
            list_ci.append(ci_index)
        self.weight_criteria = self.weight_criteria.assign(
            weights=list_wc, CI_weights=list_ci
        )

    def __subcriteria(self, df_file):
        df_file = df_file[df_file.columns[7:25]]
        list_wsubs = list()

        wsubs_keys = [
            "Ambiental",
            "Económico",
            "Técnico",
            "CI_Ambiental",
            "CI_Económico",
            "CI_Técnico",
        ]
        for evaluation in range(len(df_file)):
            wsubs = {
                "Ambiental": None,
                "Económico": None,
                "Técnico": None,
                "CI_Ambiental": None,
                "CI_Económico": None,
                "CI_Técnico": None,
            }

            df_subs = df_file.iloc[evaluation]
            i = 0
            for batch in range(0, len(df_subs), 6):
                name_matrix = f"Subcriterios {wsubs_keys[i]} - experto {evaluation + 1}"
                weights, ci_index = self.__criteria_matriz_by_expert(
                    df_subs.iloc[batch : batch + 6], name_matrix=name_matrix
                )
                wsubs[wsubs_keys[i]] = weights
                wsubs[wsubs_keys[i + 3]] = ci_index
                i += 1
            list_wsubs.append(wsubs)
        df_wsubs = pd.DataFrame.from_dict(list_wsubs)
        self.weight_criteria = pd.concat([self.weight_criteria, df_wsubs], axis=1)

    def __expert_mail(self, df_experts):
        self.weight_criteria = df_experts[df_experts.columns[-1:]]

    def from_excel(self, path):
        """Extracts the pairwise comparison information contained in an Excel workbook
        in Google Forms results format.

        Args:
            path (str): relative path of the Excel file.
        """
        __file = open_excel(path=path)
        self.__expert_mail(__file)
        self.__criteria(__file)
        self.__subcriteria(__file)

        # self.show_info()

    def show_info(self):
        """_summary_"""
        print("#####Resultados de encuestas#####")
        series = {
            "Experto": self.weight_criteria.index,
            "[C1:Ambiental  C2:Económico C3:Técnico]": self.weight_criteria[
                "weights"
            ].tolist(),
        }

        df_2print = pd.DataFrame(series)
        print_table("Criterios", df_2print)
        series = {
            "Experto": self.weight_criteria.index,
            "[C1.1:Emisión  C1.2:Suelo C1.3:Impacto]": self.weight_criteria[
                "Ambiental"
            ].tolist(),
        }

        df_2print = pd.DataFrame(series)
        print_table("Subcriterios Ambientales", df_2print)
        series = {
            "Experto": self.weight_criteria.index,
            "[C2.1:LCOE     C2.2:CAPEX    C2.3:OPEX]": self.weight_criteria[
                "Económico"
            ].tolist(),
        }

        df_2print = pd.DataFrame(series)
        print_table("Subcriterios Económicos", df_2print)
        series = {
            "Experto": self.weight_criteria.index,
            "[C3.1:Eficiencia C3.2:Despachabilidad C3.3:Autonomía]": self.weight_criteria[
                "Técnico"
            ].tolist(),
        }

        df_2print = pd.DataFrame(series)
        print_table("Subcriterios Técnicos", df_2print)
        series = {
            "Experto": self.weight_criteria.index,
            "[CI Criterios]": self.weight_criteria["CI_weights"].tolist(),
        }

        df_2print = pd.DataFrame(series)
        print_table("Consistencia", df_2print)


if __name__ == "__main__":
    test_obj = Criteria()
    test_obj.show_all = True
    test_obj.from_excel(path="../Repo/Articulo1/Encuesta/Resultados-9-02-2023.xlsx")
    test_obj.show_info()
