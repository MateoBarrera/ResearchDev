import os
import pandas as pd
import numpy as np
from pathlib import Path

from prettytable import PrettyTable

def open_excel(path, sheet_name="Form Responses 1"):
    result = pd.read_excel(path, sheet_name=sheet_name)
    result = result.dropna(axis=1,how='all')
    #print(result.head())
    return result

def print_table(title, series):
    table = PrettyTable()
    table.title = title
    table.field_names = series.columns.tolist()
    for row in series.itertuples():
        table.add_row([row.Experto, row[2]])
    print(table)

def print_evaluation(name_matrix, matrix, wj):
    table = PrettyTable()
    table.title = name_matrix
    matrix = np.round_(matrix, decimals = 2)
    if wj.any()==None:
        consistency = "NO"
    else:
        wj = np.round_(wj, decimals = 2)
        consistency = "OK"
    table.field_names = ["Matriz", "Consistencia" ,"Vector de pesos"]
    table.add_row([matrix, consistency, wj])
    print(table)


class Criteria:
    """This class The criteria class allows the loading of peer evaluations generated by experts, constructing the matrix of weights per criterion used in the MCDA method.
    """    
    weight_criteria: object
    weight_subcriteria: object
    __show: bool
    def __init__(self) -> None:
        self.__show = False
        pass
    
    @property
    def show_all(self):
        return self.__show
    
    @show_all.setter
    def show_all(self, value):
        if type(value) is bool:
            self.__show = value
            print(f"SHOW {value}")
        pass

    def __consistency_index(self, n, lmax):
        if n == 2:
          CI = 0
          CR = 0
        else:
            RI = {3:0.5247, 4:0.8816, 5:1.1086, 6:1.2479, 7:1.3417, 8:1.4057, 9:1.4499, 10:1.4854}
            CI = (lmax-n)/(n-1)
            CR = CI/RI[n]
        return CI, CR

    def __consistency_check(self, matrix, name_matrix):
        sum_rows = np.sum(matrix,0)
        normalized_matrix = matrix/sum_rows
        wj = np.mean(normalized_matrix,1)

        #wj = [round(x,6) for x in wj]
        
        cj = np.sum(matrix*wj,1)
        dj = cj/wj
        lmax = np.mean(dj)    
        
        CI, CR = self.__consistency_index(len(matrix),lmax) 
        if CR>0.10:
            wj = None
        if self.__show:
            print_evaluation(name_matrix, matrix, wj)
        return wj

    def __criteria_matriz_by_expert(self, df, name_matrix):
        """[ambiental económico técnico]"""
        size_matrix = int(len(df)/2)
        def cx(text): return int(list(str(text).split()[0])[-2]) if (str(text)[0] == "C") else int(str(text).split(".")[0])
        df = df.apply(cx)
        dim = list()
        value = list()
        for item in range(len(df)):
            if item % 2 == 0:
                dim.append(df[item])
            else:
                value.append(df[item])
        matrix = np.ones([size_matrix, size_matrix])
        expected = [1,1,2]
        for row_index in range(size_matrix):
            for column_index in range(size_matrix):
                if row_index<column_index:
                    aux = row_index + column_index - 1
                    if (dim[aux] == expected[aux]):
                        matrix[row_index, column_index] = float(value[aux])
                        matrix[column_index, row_index] = 1/float(value[aux])
                    else:
                        matrix[row_index, column_index] = 1/float(value[aux])
                        matrix[column_index, row_index] = float(value[aux])
        return self.__consistency_check(matrix, name_matrix)
    
    def __criteria(self, df):
        df = df[df.columns[1:7]]
        list_wc = list()
        for evaluation in range(len(df)):
            name_matrix = f"Criterios experto {evaluation + 1}"
            list_wc.append(self.__criteria_matriz_by_expert(df.iloc[evaluation], name_matrix=name_matrix))
        self.weight_criteria = self.weight_criteria.assign( wc = list_wc)
        
    def __subcriteria(self, df):
        df = df[df.columns[7:25]]
        list_wsubs = list()
        wsubs_keys = ['Ambiental', 'Económico', 'Técnico']
        for evaluation in range(len(df)):
            wsubs = {'Ambiental':None, 'Económico':None, 'Técnico':None}
            df_subs = df.iloc[evaluation]
            i = 0
            for batch in range(0, len(df_subs),6):
              name_matrix = f"Subcriterios {wsubs_keys[i]} - experto {evaluation + 1}"
              wsubs[wsubs_keys[i]] = self.__criteria_matriz_by_expert(df_subs.iloc[batch:batch+6], name_matrix=name_matrix)
              i+=1
            list_wsubs.append(wsubs)
        df_wsubs = pd.DataFrame.from_dict(list_wsubs)
        self.weight_criteria = pd.concat([self.weight_criteria, df_wsubs], axis=1)

    def __expert_mail(self, df):
        self.weight_criteria = df[df.columns[-1:]]
    
    def from_excel(self, path):
        """Extracts the pairwise comparison information contained in an Excel workbook in Google Forms results format.

        Args:
            path (str): relative path of the Excel file.
        """      
        __file = open_excel(path=path)  
        self.__expert_mail(__file)
        self.__criteria(__file)
        self.__subcriteria(__file)

        #self.show_info()
   
    def show_info(self):
        print("#####Resultados de encuestas#####")
        series = {"Experto": self.weight_criteria.index, "[C1:Ambiental  C2:Económico C3:Técnico]":self.weight_criteria['wc'].tolist()}
        df = pd.DataFrame(series)
        print_table("Criterios", df)
        series = {"Experto": self.weight_criteria.index, "[C1.1:Emisión  C1.2:Suelo C1.3:Impacto]":self.weight_criteria['Ambiental'].tolist()}
        df = pd.DataFrame(series)
        print_table("Subcriterios Ambientales", df)
        series = {"Experto": self.weight_criteria.index, "[C2.1:LCOE     C2.2:CAPEX    C2.3:OPEX]":self.weight_criteria['Económico'].tolist()}
        df = pd.DataFrame(series)
        print_table("Subcriterios Económicos", df)
        series = {"Experto": self.weight_criteria.index, "[C3.1:Eficiencia C3.2:Despachabilidad C3.3:Autonomía]":self.weight_criteria['Técnico'].tolist()}
        df = pd.DataFrame(series)
        print_table("Subcriterios Técnicos", df)
  

if __name__ == "__main__":
    test_obj = Criteria()
    test_obj.show_all = False
    test_obj.from_excel(path="../Repo/Articulo1/Encuesta/Resultados-9-02-2023.xlsx")
    test_obj.show_info()