"""Alternative file

This module includes the class for generate the scenarios/alternatives specifications

Autor: Mateo Barrera
Date: 11-03-2023
"""
import numpy as np
import pandas as pd
from itertools import product
from prettytable import PrettyTable


class Alternatives:
    def __init__(
        self,
            resources_included=None,
            seed=None,
            installed_capacity: float = 100,
    ) -> None:
        """
        **Alternatives** object allow the scenario construction base in all possible combinations of resources.
        The class required a list of resources that have the minimum viability check, and a specific percentage
        of penetration level.

        *__init__* function is the first function that gets called when you create a new object.
        Its job is to initialize the attributes of an object.

        *resources_included* ->  internal interpretation ([solar, wind, hydro, biomass])

        :param resources_included: list[int]: Define the list of resources that are included in the model.
        :param seed: list[float]: Set the initial value of the seed
        :param installed_capacity: float: Set the installed capacity of resources included in the portfolio
        :return: None


        :doc-author: Trelent
        """
        if seed is None:
            seed = [1.0, 0.5, 0.25, 0]
        if resources_included is None:
            resources_included = [1, 1, 1, 1]

        self.resources_included = resources_included
        self.seed = seed
        self.installed_capacity = installed_capacity
        self.alternatives, self.scenarios = self.__generate_scenarios()
        # return self.alternatives

    def __str__(self) -> str:
        """
        *__str__* function is called when you use the print() function or when you use str() to convert an object to
        a string.
        The main string format for **Alternative** object base on `describe_scenario`_ method.

        :param self: Refer to the object itself
        :return: A string that describes the scenarios in a scenario set
        :doc-author: Trelent
        """

        return self.__describe_scenarios()

    def get(self):
        """
        The get function returns the list of alternatives for a given question.

        :param self: Represent the instance of the class
        :return: The list of alternatives
        :doc-author: Trelent
        """
        return self.alternatives

    def __generate_scenarios(self):

        """
        The __generate_scenarios function generates all possible scenarios for the given resources.
        

        :param self: Represent the instance of the class
        :return: A dataframe and a list
        :doc-author: Trelent
        """
        (
            solar_inclusion,
            wind_inclusion,
            hydro_inclusion,
            biomass_inclusion,
        ) = self.resources_included

        all_combinations = list(product(*[self.seed] * 4))

        weight_scenarios = np.array(all_combinations)
        y_resources = np.array(
            [solar_inclusion, wind_inclusion, hydro_inclusion, biomass_inclusion]
        )

        scenario_matrix = weight_scenarios * y_resources
        scenario_array = list()
        for items in scenario_matrix:
            if sum(items) == 1:
                scenario_array.append(str(list(items)))

        scenario_array = list(dict.fromkeys(scenario_array))
        scenario_array = [eval(i) for i in scenario_array]

        # self.__describe_scenarios(scenario_array)
        alternatives_df = pd.DataFrame(
            columns=["solar", "wind", "hydro", "biomass"], data=scenario_array
        )
        return alternatives_df, scenario_array

    def __describe_scenarios(self):
        """
        ref: `describe_scenarios`
        *__describe_scenarios* function is a private method that returns a string containing
        a summary of the scenarios generated by the ScenarioGenerator class.

        The summary includes:
            - The target-installed capacity (in kW) for which scenarios are being generated.
            - A list of resources included in each scenario, and whether they are included.
              This is determined by the user-specified resource_included argument passed to __init__().
              If resource_included[i] == 1, then resource *i* will be included in all scenarios; otherwise it will not
              be used at all.

        :param self: Represent the instance of the class
        :return: A string with the summary of the scenarios
        :doc-author: Trelent
        """
        info = PrettyTable()
        info.title = "ALTERNATIVES SUMMARY"
        info.field_names = ["TARGET CAPACITY ", f"{self.installed_capacity} kW"]
        info.add_row(["---------------------", "-----------"])
        info.add_row(["TOTAL ALTERNATIVES", "{}".format(len(self.scenarios))])
        info.add_row(["---------------------", "-----------"])
        info.add_row(["RESOURCES", "INCLUDED"])
        for resource in zip(
            ["solar", "wind", "hydro", "biomass"], self.resources_included
        ):
            if resource[1] == 1:
                info.add_row([resource[0], "\N{check mark}"])
            else:
                info.add_row([resource[0], "\N{Ballot X}"])
        info.add_row(["---------------------", "-----------"])
        text = ["% VARIATIONS FOR", "INSTALLED CAPACITY", "TARGET"] + [
            " " for _ in range(len(self.seed) - 3)
        ]
        for index, x in enumerate(self.seed):
            info.add_row([text[index], f"{x*100} %"])
        # info.add_row(["{} %".format(x * 100) for x in self.seed])
        scenario_matrix = PrettyTable()
        scenario_matrix.field_names = ["solar", "wind", "hydro", "biomass"]
        scenario_matrix.title = "ALTERNATIVES"
        for scenario in self.scenarios:
            scenario = list(map(lambda scenario_value: "{} %".format(scenario_value * 100), scenario))
            scenario_matrix.add_row(scenario)

        return f"\n{info}\n{scenario_matrix}"


if __name__ == "__main__":
    alternatives = Alternatives()
    print(alternatives)
    df_alternatives = alternatives.get()
    print(df_alternatives)
